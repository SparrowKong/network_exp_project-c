# 计算机网络实验项目 (network_exp_project-c)

这是一个用于计算机网络课程的教学实验项目，包含多个网络协议的实现和演示。每个实验都具有详细的中文注释，简洁的代码结构，以及完整的测试用例。

## 项目结构

```
network_exp_project-c/
├── src/                              # 源代码目录
│   ├── sliding_window_protocol/      # 滑动窗口协议实验
│   │   ├── core/                     # 核心实现代码
│   │   │   ├── sliding_window.h      # 协议头文件
│   │   │   └── sliding_window.c      # 协议实现
│   │   ├── frontend/                 # 用户交互界面
│   │   │   └── interface.c           # 交互界面实现
│   │   └── test/                     # 测试用例
│   │       └── test_sliding_window.c # 测试程序
│   └── crc_algorithm/                # CRC校验算法实验
│       ├── core/                     # 核心实现代码
│       │   ├── crc_algorithm.h       # CRC算法头文件
│       │   └── crc_algorithm.c       # CRC算法实现
│       ├── frontend/                 # 用户交互界面
│       │   └── interface.c           # 交互界面实现
│       └── test/                     # 测试用例
│           └── test_crc_algorithm.c  # 测试程序
├── build/                            # 编译输出目录（按实验分离）
│   ├── sliding_window_protocol/      # 滑动窗口协议编译文件
│   │   ├── core.o                    # 核心模块对象文件
│   │   ├── frontend.o                # 界面模块对象文件
│   │   └── test.o                    # 测试模块对象文件
│   └── crc_algorithm/                # CRC算法编译文件
│       ├── core.o                    # 核心模块对象文件
│       ├── frontend.o                # 界面模块对象文件
│       └── test.o                    # 测试模块对象文件
├── bin/                              # 可执行文件目录（按实验分离）
│   ├── sliding_window_protocol/      # 滑动窗口协议可执行文件
│   │   ├── demo                      # 演示程序
│   │   └── test                      # 测试程序
│   └── crc_algorithm/                # CRC算法可执行文件
│       ├── demo                      # 演示程序
│       └── test                      # 测试程序
├── Makefile                          # 支持多实验的构建配置文件
├── CLAUDE.md                         # AI 开发助手配置
└── README.md                         # 项目说明文档
```

---

## 实验1: 滑动窗口协议（停等协议）

### 实验简介

滑动窗口协议是计算机网络中重要的数据链路层协议。本实验实现了最简单的滑动窗口协议——停等协议（Stop-and-Wait Protocol），窗口大小为1。

### 功能特性

- ✅ **完整的停等协议实现**: 包含发送方和接收方的完整状态机
- ✅ **网络环境模拟**: 支持可配置的丢包率和网络延迟
- ✅ **错误检测与校验**: 实现简单的校验和机制
- ✅ **超时重传**: 支持超时检测和自动重传
- ✅ **详细的中文日志**: 实时显示协议执行过程
- ✅ **性能统计**: 提供传输成功率、重传率等统计信息
- ✅ **交互式界面**: 用户友好的命令行界面
- ✅ **完善的测试**: 包含10个测试用例，覆盖各种场景

### 编译和运行

#### 通用构建命令
```bash
make                          # 构建所有实验
make list                     # 列出所有可用实验
make experiments              # 构建所有实验（同make）
make test                     # 运行所有实验的测试
make demo                     # 交互式选择并运行演示
make clean                    # 清理所有编译文件
make help                     # 显示详细帮助信息
```

#### 特定实验命令
```bash
# 滑动窗口协议实验
make sliding_window_protocol        # 构建该实验
make sliding_window_protocol-demo   # 运行该实验演示程序
make sliding_window_protocol-test   # 运行该实验测试
make sliding_window_protocol-clean  # 清理该实验编译文件

# 直接运行程序
./bin/sliding_window_protocol/demo  # 直接运行演示程序
./bin/sliding_window_protocol/test  # 直接运行测试程序
```

#### 系统安装（可选）
```bash
make install        # 安装到系统目录 /usr/local/bin/
make uninstall      # 从系统目录卸载
```

### 实验内容

#### 1. 协议原理
停等协议的工作流程：
1. 发送方发送一个数据帧，启动计时器
2. 等待接收方的确认帧（ACK）
3. 如果收到正确的ACK，发送下一帧
4. 如果超时或收到错误的ACK，重传当前帧
5. 重复上述过程直到传输完成

#### 2. 核心功能模块

**核心协议实现** (`src/sliding_window_protocol/core/`)
- `sliding_window.h` - 协议头文件，定义数据结构和函数接口
- `sliding_window.c` - 协议核心实现，包含发送、接收、重传逻辑

**用户交互界面** (`src/sliding_window_protocol/frontend/`)
- `interface.c` - 提供友好的命令行界面，支持参数配置和结果展示

**测试用例** (`src/sliding_window_protocol/test/`)
- `test_sliding_window.c` - 包含10个全面的测试用例

#### 3. 实验场景

**理想网络环境**: 
- 丢包率: 0%
- 延迟: 10-50ms
- 预期结果: 无重传，高效传输

**一般网络环境**: 
- 丢包率: 10%
- 延迟: 50-150ms
- 预期结果: 少量重传，传输成功

**恶劣网络环境**: 
- 丢包率: 30%
- 延迟: 200-500ms
- 预期结果: 多次重传，可能传输失败

### 学习要点

1. **理解ARQ协议**: 掌握自动重传请求的基本原理
2. **序列号机制**: 理解序列号的循环使用（0和1）
3. **超时重传**: 学习超时检测和重传策略
4. **错误检测**: 了解简单校验和的计算方法
5. **网络建模**: 理解网络丢包和延迟对协议性能的影响

### 性能分析

通过实验可以观察和分析：
- 网络环境对传输效率的影响
- 超时时间设置的重要性
- 重传次数与网络质量的关系
- 停等协议的优缺点

### 实验扩展

可以基于当前实现进行以下扩展：
- 实现更大窗口的滑动窗口协议
- 添加选择重传（Selective Repeat）机制
- 实现更复杂的错误检测算法
- 添加流量控制机制

---

## 实验2: CRC校验算法（循环冗余校验）

### 实验简介

CRC（Cyclic Redundancy Check，循环冗余校验）是计算机网络和通信系统中广泛使用的错误检测算法。本实验实现了多种标准的CRC算法，包含详细的教学演示和性能分析功能。

### 功能特性

- ✅ **多种CRC标准支持**: 实现CRC-8、CRC-16、CRC-16-CCITT、CRC-32
- ✅ **双重算法实现**: 提供位级算法（教学）和查表算法（高效）
- ✅ **教学导向设计**: 逐步展示CRC计算过程和多项式除法
- ✅ **错误检测演示**: 模拟数据传输错误并验证CRC检测能力
- ✅ **性能对比分析**: 比较不同算法实现的计算效率
- ✅ **完整交互界面**: 支持文本和十六进制数据输入
- ✅ **批量测试功能**: 使用标准测试向量验证算法正确性
- ✅ **详细统计报告**: 提供计算时间和错误检测统计

### 编译和运行

#### 特定实验命令
```bash
# CRC算法实验
make crc_algorithm              # 构建该实验
make crc_algorithm-demo         # 运行该实验演示程序
make crc_algorithm-test         # 运行该实验测试
make crc_algorithm-clean        # 清理该实验编译文件

# 直接运行程序
./bin/crc_algorithm/demo        # 直接运行演示程序
./bin/crc_algorithm/test        # 直接运行测试程序
```

### 实验内容

#### 1. CRC算法原理

CRC算法基于多项式除法运算：
1. 将输入数据视为多项式的系数
2. 将数据多项式左移n位（n为CRC位宽）
3. 用生成多项式进行模2除法运算
4. 除法的余数即为CRC校验值

#### 2. 支持的CRC标准

| CRC类型 | 位宽 | 生成多项式 | 应用场景 |
|---------|------|------------|----------|
| CRC-8 | 8位 | 0x07 | 简单应用、传感器网络 |
| CRC-16 | 16位 | 0x8005 | 工业控制、Modbus协议 |
| CRC-16-CCITT | 16位 | 0x1021 | 电信、X.25协议 |
| CRC-32 | 32位 | 0x04C11DB7 | 以太网、ZIP压缩 |

#### 3. 核心功能模块

**核心算法实现** (`src/crc_algorithm/core/`)
- `crc_algorithm.h` - CRC算法头文件，定义数据结构和函数接口
- `crc_algorithm.c` - CRC算法核心实现，包含位级和查表算法

**用户交互界面** (`src/crc_algorithm/frontend/`)
- `interface.c` - 提供完整的菜单系统，支持多种功能演示

**测试验证模块** (`src/crc_algorithm/test/`)
- `test_crc_algorithm.c` - 包含14个测试用例，全面验证算法正确性

#### 4. 功能演示

**1. CRC计算与验证**
- 支持文本字符串和十六进制输入
- 实时显示计算过程和结果
- 提供数据完整性验证功能

**2. 错误检测能力演示**
- 自动注入比特错误
- 演示CRC错误检测过程
- 分析单比特和多比特错误的检测能力

**3. 算法性能比较**
- 对比位级算法和查表算法的性能
- 测试不同数据长度的处理效率
- 显示详细的性能提升倍数

**4. 教学模式**
- 逐步展示CRC计算过程
- 可视化多项式除法运算
- 展示CRC查找表的生成过程
- 解释算法的数学原理

**5. 批量测试**
- 使用标准测试向量验证算法
- 支持多种CRC标准的批量计算
- 自动验证结果正确性

#### 5. 实验场景

**基础学习场景**:
- 输入简单字符串如"Hello"
- 观察不同CRC标准的计算结果
- 理解CRC值的含义和用途

**算法理解场景**:
- 使用教学模式逐步计算
- 观察多项式除法过程
- 理解查找表的优化原理

**性能测试场景**:
- 测试大数据量的CRC计算
- 比较不同算法的执行效率
- 分析算法时间复杂度

**错误检测场景**:
- 模拟数据传输错误
- 验证CRC的错误检测能力
- 分析不同错误类型的检测率

### 学习要点

1. **理解CRC原理**: 掌握基于多项式除法的错误检测机制
2. **算法优化**: 了解查找表如何提升计算效率
3. **标准应用**: 学习不同CRC标准的特点和应用场景
4. **错误检测**: 理解CRC对不同类型错误的检测能力
5. **工程实践**: 掌握在实际项目中如何选择和使用CRC

### 性能分析

通过实验可以观察和分析：
- 查表算法相比位级算法的性能提升
- 不同CRC位宽对计算复杂度的影响
- 数据长度对算法性能的影响
- CRC算法在错误检测中的准确率

### 实验扩展

可以基于当前实现进行以下扩展：
- 实现自定义生成多项式的CRC计算
- 添加CRC算法的硬件加速模拟
- 实现更多CRC标准（如CRC-64）
- 添加CRC与其他校验算法的对比分析
- 实现网络协议中CRC的实际应用场景

---

## 技术栈

- **编程语言**: C99
- **编译器**: GCC
- **构建工具**: Make
- **测试**: 自定义测试框架
- **平台**: Linux/macOS/Windows（通过MinGW）

## 开发说明

### 代码规范
- 使用中文注释，便于学习理解
- 遵循C99标准，保证代码兼容性
- 每个函数都有详细的参数说明
- 错误处理完善，包含边界条件检查

### 项目特色
- **教学导向**: 代码结构清晰，便于教学讲解
- **中文友好**: 所有输出和注释都使用中文
- **可视化**: 详细的执行过程显示
- **可配置**: 支持多种网络环境配置
- **测试完善**: 包含全面的测试用例

## 贡献指南

欢迎贡献新的网络协议实验或改进现有实现：
1. Fork 本项目
2. 创建新的实验目录 `src/new_experiment/`
3. 按照项目结构创建 `core/`, `frontend/`, `test/` 目录
4. 实现协议并添加测试用例
5. 更新 README.md 添加新实验的说明
6. 提交 Pull Request

## 许可证

本项目采用 MIT 许可证，详见 LICENSE 文件。

## 联系方式

如有问题或建议，请通过以下方式联系：
- 提交 GitHub Issue
- 发送邮件至项目维护者

---

*本项目专为计算机网络课程教学设计，旨在帮助学生更好地理解网络协议原理。*